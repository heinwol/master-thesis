#import "./template.typ": thmrules, template, definition, theorem, proof, proposition, code, lemma, corollary, remark

#let sp = h(0.5em)

#let state_dict(d) = {
  // assert(type(d) == dictionary)
  ${#(d
    .pairs()
    .map(((k, v)) => $bold(#(k+":")) #v$)
    .join(",")
    )}$
}

#let generated_image(subpath) = {
  // assert(type(subpath) == str)
  (..args) => image("../assets/generated/" + subpath, ..args)
}

#let image_by_hand(subpath) = {
  // assert(type(subpath) == str)
  (..args) => image("../assets/images/" + subpath, ..args)
}

#let varnothing = $text(font: "Fira Sans", nothing)$

#let comment(cnt) = text(fill: red, cnt)

#let quo(l, r) = {
  $#l"/"#r$
}
#let esq(u, eqv_rel: none) = $[#u]_#( if eqv_rel == none {"~"} else {eqv_rel})$

#let Stab = $"Stab"$
#let Aut = $"Aut"$

#show: thmrules
#show: template

////////////////////////
// Document begins!
////////////////////////

= РЕФЕРАТ <nonum>

// TODO Количество страниц и тп

#context [
  #let total_pages = counter(page).final().at(0)
  #let total_images = counter(figure.where(kind: image)).final().at(0)
  #let total_references = 18
  Расчетно-пояснительная записка #total_pages с., #total_images рис., #total_references источников.
]

Ключевые слова: ГРАФОВАЯ ДИНАМИЧЕСКАЯ ПОРОГОВАЯ МОДЕЛЬ, РЕСУРСНАЯ СЕТЬ, РЕГУЛЯРНЫЙ ГРАФ, АВТОМОРФИЗМ.

Модель ресурсной сети может быть использована для моделирования перколяции, то есть протекания вещества в некоторой среде. Для этого рассматриваются сети с графами регулярной структуры -- губковые сети. Поскольку регулярные графы обладают большим количеством симметрий, то возникает естественный вопрос о том, как симметрии графа позволяют судить о симметрии ресурсной сети как динамической системы. В связи с этим нами ставятся задачи, касающиеся описания симметрий графов губковых сетей, симметрий их как динамических систем и связи между данными видами симметрий. Рассматриваются также модификации губковых сетей, полученные путем факторизации и помещения сетей на цилиндр. Указываются свойства процесса факторизации сети. Дополнительно, было доказано несколько общих утверждений, касающихся

// Ставится цель исследовать свойства таких сетей через призму симметрий графов

В работе используется аппарат теории графов, теории групп, теории динамических систем, а также данные, полученные из предыдущих исследований ресурсных сетей. Для проведения моделирования и визуализации результатов написана программа `Sponge-networks` на языке `python`, ее исходный код открыт и доступен на Github.

// -- разработка и написание программного кода, реализующего обнаружения автомобилей на изображениях. В качестве исходного набора нейросетевых архитектур используются сети YOLO и ViT. Проводится исследование точности моделей, и сравнение скорости работы.

// По результатам, полученным в ходе программной реализации, проведен
// сравнительный анализ используемых методов.

#outline(title: [Содержание])

= СПИСОК ОБОЗНАЧЕНИЙ <nonum>

- $(A -> B)$ --- множество (тип) всех функций из $A$ в $B$, т.е. $A -> B eq.def B^A = {f | f: A -> B}$. Данный оператор $(- -> -)$ является право-ассоциативным, т.е. $A -> B -> C = A -> (B -> C)$.
// - *Оператор точки $(-.-)$* --- доступ к полю структуры (по аналогии с объектно-ориентированными языками программирования) или сужение контекста. Так, если сказано, например, что $A eq.def (B, C)$, где $B eq.def (X, Y union.sq Z)$, то $A.B.X$ означает именно $X$, определенный выше, т.е. относящийся к $B$, который, в свою очередь, относится к $A$.
- *Оператор степени функции $(-^n)$*. Если $f(x)$ -- некоторая функция, то под $f^n$ понимается функция $f$ взятая в композиции с собой $n$ раз, т.е. $f^n (x) eq.def f(f(...f(x))) = underbrace(f circle.tiny f circle.tiny ... circle.tiny f, n "раз")(x)$.
- *Булеан множества $cal(P)(-)$*. Для произвольного множества $X$ булеаном этого множества $cal(P)(X) eq.def 2^X$ является множество всех его подмножеств, т.е. $cal(P)(X) = {y | y subset X}$.
- $"Gen"_(G)(V_x)$ -- подграф графа $G$, порожденный подмножеством $V_x subset V$ вершин графа $G$.

// TODO Дописать или переписать))

= ВВЕДЕНИЕ <nonum>

Сетевые модели находят много форм и приложений в современной математической науке. На основе сетевых моделей строятся нейронные сети, модели социальных сетей, автоматы, многоагентные системы и т.п. Одним из направлений исследований сетевых моделей являются ресурсные сети.

Модель ресурсной сети представляет из себя ориентированный граф, в каждой вершине которого располагается некоторое количество так называемого ресурса (некоторое неотрицательное вещественное число). Вершины могут накапливать сколь угодно большое количество ресурса. Модель представляет из себя динамическую систему в дискретном времени, похожую на цепь Маркова. Как и в цепи Маркова, на каждом такте между соседними вершинами происходит перераспределение значений чисел, приписанных к вершинам, так, чтобы суммарное количество ресурса осталось неизменным (ресурс не появляется из ниоткуда и не исчезает в пустоту). Если суммарное количество ресурса в сети невелико, то ресурсная сеть функционирует как цепь Маркова (с поправкой на некоторый коэффициент). Однако же в случае большого суммарного ресурса в силу вступают нелинейные факторы: согласно определению ресурсной сети, вершина не может отдать по ребру ресурса больше, чем пропускная способность этого ребра.

Понятие ресурсной сети было впервые предложено Кузнецовым О.П. в 2009 году @Kuznetsov2009. Данная тема получила широкое развитие: были исследованы многие свойства обыкновенных ресурсных сетей. Так, в монографии Жиляковой Л.Ю. @ЖИЛЯКОВА2013 были вычленены основные характеристики ресурсных сетей (например, пороговое значение ресурса, вершины-аттракторы) и предложена классификация сетей. Был проведен полный анализ поведения нерегулярных ресурсных сетей при малом количестве ресурса, эйлеровых сетей, регулярных сетей и др. Можно отметить и работу @Zhilyakova2022, в которой с помощью ресурсных сетей были получены результаты в теории стохастических матриц и неоднородных цепей Маркова. Рассматривалось также и множество модификаций указанной модели. Особого внимания заслуживает модификация ресурсной сети с «жадными» вершинами @Чаплинская2021. Исследовались также и приложения ресурсных сетей к моделированию реальных процессов, например, распространения вещества в жидкой среде @Zhilyakova2012.

Данная работа предлагает еще одно приложение ресурсных сетей: моделирование перколяции, т.е. просачивания в некоторой среде. Каноническим трудом является @Bollobas_Riordan_2006, где описаны основные модели, исследующие это явление. Исследование перколяции как направления математики активно и по сей день, примером чему может служить @Li2021. Отметим, однако, что основным методом исследования перколяции является теория случайных графов. Мы же предлагаем несколько иное прочтение понятия перколяции и иной способ моделирования -- с помощью регулярных ресурсных сетей (названных _губковыми сетями_), которые являются модификацией модели ресурсной сети.

Мы сконцентрируемся на симметриях губковых сетей в качестве нашей основной цели исследования. Мотивацией такого выбора является соображение о том, что основное свойство регулярных структур (в том числе графов) в их симметричности и периодичности. В этом же смысле и стоит понимать основное отличие губковых сетей от ресурсных сетей вообще. Однако возникает следующий вопрос: если графы ресурсной сети обладают некоторой симметрией, то как это отразится на функционировании соответствующей динамической системы? Сохранится ли эта "симметричность", и если да, то в каком смысле? На эти вопросы мы и попытаемся ответить в данной работе.

Объектом исследования работы являются регулярные ресурсные сети, предметом -- их симметрии. Цель работы состоит в описании всех симметрий губковых сетей как графов и проведение связи между симметриями их как графов и как динамических систем. Ставятся следующие задачи:
- Построить модель регулярной ресурсной сети (губковой сети);
- Описать связь симметрий регулярных замощений плоскости и симметрий губковых сетей;
- Описать полную группу симметрий губковых сетей;
- Ввести понятие факторизации губковых сетей, установить базовые свойства сетей при факторизации;
- Рассмотреть симметрии регулярных сетей после некоторых факторизаций, в частности, после помещения их на цилиндр;
- Установить связь между симметриями графов губковых сетей и симметриями динамических систем, порождающихся ресурсными сетями.

= Основные понятия

== Модель ресурсной сети

Неформально говоря, ресурсная сеть -- ориентированный размеченный граф, в каждой вершине которого находится некоторое количество «ресурса». Ресурс есть некоторое неотрицательное вещественное число. Можно мыслить о ресурсе как о жидкости, к примеру. Ресурсная сеть образует динамическую систему с дискретным временем. А именно, каждый такт ресурс перераспределяется между вершинами так, чтобы суммарное количество ресурса в сети оставалось неизменным. Каждая вершина «отдает» в каждое из своих ребер ресурс, пропорциональный пропускной способности (метке) этого ребра, но не больше, чем сама пропускная способность. Таким образом, если в каждой вершине ресурса достаточно мало, то система функционирует эквивалентно цепи Маркова (с поправкой на некоторый коэффициент). Если же ресурса много, то в каждую вершину приходит столько ресурса, какова суммарная пропускная способность входящих в эту вершину ребер (по крайней мере, некоторое время). Оба этих случая по отдельности кажутся очень простыми, однако сложность представляет исследование именно промежуточных состояний, то есть таких, при которых часть вершин содержит мало ресурса, а часть -- много.

Определим теперь понятие ресурсной сети более формально.

#definition[
  *Ресурсная сеть* -- это тройка $"SN" = (G, D, S)$, где:
]
- $G = (V, E)$ -- ориентированный граф, дуги $E$ которого размечены над множеством $RR_+$ неотрицательных вещественных чисел, а $|V| = n$. Метки дуг лучше всего понимать как аналог пропускной способности. Предположим, что зафиксирована некоторая нумерация вершин $"num" : V -> overline(1"," n) .$ Тогда метку дуги $e_(i j)$ будем записывать как $r_(i j)$ ($r_(i j) = 0$ если дуги не существует);

- $D$ -- множество (допустимых) состояний динамической системы, т.е. некоторое подмножество множества $(V arrow.r med bb(R)_(+))$. Менее формально говоря: каждой вершине $v$ может быть присвоено некоторое значение из множества $bb(R)_(+)$, но, вообще говоря, не все значения из $bb(R)_(+)$ могут быть допустимыми. Произвольное состояние из $D$ будем обозначать как $q in D$. Если нумерация вершин считается фиксированной, то под $q$ будем понимать $n$-мерный вектор.

- $S : D -> D$ -- функция эволюции динамической системы, при этом $S$ однозначно определяется $G$ и $D$. Более подробное описание функции $S$ будет приведено ниже.

_Примечание:_ Как можно видеть, довольно сложно сформулировать определение ресурсной сети, инвариантное относительно выбранной нумерации вершин. В связи с этим для легкости дальнейшего изложения зафиксируем нумерацию, покуда это не вызовет недопониманий.

#definition[
  *Ресурсы* $q_i (t)$ -- неотрицательные числа, присвоенные вершинам $v_i; #h(0.6em) i = overline(1"," n)$ и изменяющиеся в дискретном времени $t$.

  *Состояние* $Q(t)$ c на временном шаге $t$ представляет собой вектор-строку значений ресурсов в каждой вершине: $q(t) = (q_1(t), q_2(t), ..., q_(n)(t))$.
]

#definition[
  *Матрица пропускной способности* ресурсной сети -- $R eq.def (r_(i j))_(n times n)$. В~сущности, это матрица смежности графа $G$ с весами из $RR_+$.
]

#definition[
  *Стохастическая матрица* ресурсной сети:

  $
  R' eq.def
  mat(
      delim: "(",
      r_11 / r_1^("out"), dots.h.c, r_(1 n) / r_1^("out");
      dots.v, dots.down, dots.v;
      r_(n 1) / r_n^("out"), dots.h.c, r_(n n) / r_n^("out")
    ),
  $ <nonum>

  где $bold(r_i^("out")) eq.def sum_(j=1)^n r_(i j)$.

  Матрица $R'$ называется стохастической потому, что если рассмотреть цепь Маркова, построенную по тому же графу $G$, что и ресурсная сеть, отнормировав при этом веса ребер так, чтобы в каждой строке матрицы смежности сумма значений была равна единице, то получим в точности матрицу $R'$.
]

#definition[
  *Матрица потока* ресурсной сети:

  $ F(q) eq.def min {R' dot.circle (bold(1) dot.op q), R}, $ <nonum>

  где min применяется поэлементно, $dot.circle$ -- произведение Адамара, $bold(1)$ -- вектор-столбец из единиц.

  Поток из $i$-й вершины в $j$-ю есть в точности то количество ресурса, которое придет из $i$-й вершины в $j$-ю под действием $S$. Следует отметить, что
  + ресурсы, приходящие из разных вершин, складываются и
  + если суммарный выходной поток меньше текущего количества ресурса в вершине, то излишек не пропадает, а остается в вершине.
] <def:flow-matrix>

Таким образом, можно определить, наконец, функцию эволюции динамической системы $S$:

$ S(q) eq.def q - (F(q) dot bold(1))^T + bold(1)^T dot F(q) $ <eq:S>

Дискретная динамическая система определяется стандартно: пусть дано некоторое начальное состояние $q^0 in D,$ тогда определим:

$
cases(
  q(0) &= q^0";",
  q(t) &= S(q(t-1))"," sp t in NN.
)
$

#definition[
  Пусть дано некоторое состояние $q$ ресурсной сети. Тогда определим

  $
  Z^(-)(q) = {v_i in G | q_i <= r_i^("out")};\
  Z^(+)(q) = {v_i in G | q_i > r_i^("out")},
  $

  Очевидно, что $forall q in RR_(+)^n sp Z^(+)(q) union.sq.big_()^() Z^(-)(q) = V$. Если вершина принадлежит $Z^(+)(q)$, то говорим, что она *работает по правилу 1*. Если же вершина принадлежит $Z^(-)(q)$, то говорим, что она *работает по правилу 2*.
]

#let state_1 = ("0": 8, "1": 1, "2": 0)

Пример ресурсной сети $"network"_1$ можно видеть на @fig:basic_network_1. Множество вершин здесь есть $V = {0, 1, 2}$, а метки ребер обозначают соответствующие веса в графе $G$. На @fig:basic_network_2 показано некоторое состояние сети с ресурсами #state_dict(state_1). При данном способе визуализации вершины имеют разный размер в зависимости от количества имеющегося в них ресурса. Более того, вершины $v_i$, в которых ресурс не меньше порогового значения (т.е. $q_i >= r_i^("out")$), окрашены в фиолетовый цвет, а остальные -- в салатовый.

#grid(
  columns: 2,
  align: bottom,
  [
    #figure(
      caption: [Ресурсная сеть $"network"_1$.],
      generated_image("basic_network/plot.svg")(width: 75%),
    ) <fig:basic_network_1>
  ],
  [
    #figure(
      caption: [Состояние сети $"network"_1$ при #state_dict(state_1).],
      generated_image("basic_network/sim.svg")(),
    ) <fig:basic_network_2>
  ],
)

Матрица пропускной способности $"network"_1$ приведена в уравнении @eq:basic_network_R, а ее стохастическая матрица -- в уравнении @eq:basic_network_R_1. Можно убедиться, что сумма значений в каждой строке стохастической матрицы равна единице.

#grid(
  columns: 2,
  [
    $
    R = mat(
        0, 3, 1;
        4, 1, 0;
        2, 2, 0;
    )
    $ <eq:basic_network_R>
  ],
  [
    $
    R' = mat(
      0   , 0.75, 0.25;
      0.8 , 0.2 , 0   ;
      0.5 , 0.5 , 0   ;
    )
    $ <eq:basic_network_R_1>
  ],
)

Исходя из формы определения матрицы потока @def:flow-matrix, можно объяснить механизм функционирования ресурсной сети более наглядно. Если предположить, что в некотором состоянии все вершины работают по правилу 1 (т.е. $Z^+(q) = V$), то из @eq:S и определения @def:flow-matrix получим

$ S(q) = q - (R dot bold(1))^T + bold(1)^T dot R = q + 1^T (R - R^T). $ <nonum>

Иначе говоря, в этой ситуации модель напоминает потоковую @Goldberg1989, поток не зависит от текущего состояния, а только от свойств самого графа. Напротив, если предположить, что все вершины работают по правилу 2 (т.е. $Z^-(q) = V$), то окажется, что модель получается линейной:

$ S(q) = q dot R'. $ <eq:Markov>

Поскольку матрица $R'$ -- стохастическая (т.е. сумма значений в каждой строке равна 1), то модель @eq:Markov аналогична модели цепи Маркова с непрерывным состоянием и дискретным временем @Dynkin1965.

Отметим, что "большая часть" ресурсных сетей в пределе ведут себя во многом идентично цепям Маркова. Подробное и объемлющее описание поведения обычных ресурсных сетей приведено в @ЖИЛЯКОВА2013.

== Модель ресурсной сети с жадными вершинами

Данная модификация модели обыкновенной ресурсной сети была предложена Чаплинской Н.В. в @Жилякова2021, а затем исследована в работах @Чаплинская2021 @Чаплинская2021a. Суть модели в следующем: вершины, обладающие петлей (т.е. $e_(i i) in G.E$) отдают свой ресурс сначала в петлю, а остаток распределяют уже согласно обыкновенному закону функционирования ресурсной сети. Получается, что такие вершины -- "запасливые", пытающиеся сначала "отложить" ресурс себе, а уже потом распределять его между соседями. Из такой аналогии и проистекает их название.

Одно из интересных свойств такой сети состоит в том, что при достаточно маленьком количестве ресурса и при выполнении некоторых дополнительных свойств достижимости в графе и при некотором начальном распределении ресурса по вершинам происходит так называемая "остановка" сети: 70% ресурса оказывается сосредоточено в жадных вершинах, при этом вершина не может отдавать ресурс никуда, помимо петли (поскольку ресурса у нее недостаточно). Получается, что поток в сети оказывается нулевым (за исключением петель, в которые все время поступает весь ресурс из вершин). Естественно, динамическая система оказывается стабилизированной в том смысле, что $S(q) = S^2(q)$. Пример останавливающейся сети и ее начального состояния приведены на @fig:stop_network_1, а остановившаяся сеть -- на @fig:stop_network_2.

#grid(
  columns: 2,
  align: bottom,
  [
    #figure(
      caption: [Начальное состояние стабилизирующейся сети.],
      generated_image("stop_network/sim1.svg")(),
    ) <fig:stop_network_1>
  ],
  [
    #figure(
      caption: [Та же сеть в остановившемся состоянии.],
      generated_image("stop_network/sim2.svg")(),
    ) <fig:stop_network_2>
  ],
)

Более подробное описание ситуаций, в которых сети демонстрируют подобное поведение представлено в @Чаплинская2021 (например, утверждение 5).

= Результаты

== Губковые сети

Особый интерес нашего исследования представляют *губковые сети*. Относить к губковым сетям мы будем ресурсные сети с жадными вершинами, имеющими специфическую топологию. А именно, будем рассматривать графы, являющиеся в некотором смысле регулярными (определим "регулярность" более подробно ниже), при этом у таких графов будет выделен "верх" и "низ", т.е. множество вершин, в которые в начальный момент времени будет класться ресурс и множество вершин, в которые этот ресурс может стекать. При этом подразумевается наличие некоторой ориентации: протекание ресурса "сверху вниз" должно идти быстрее, чем "снизу вверх". Более того, в целях более точной геометрической интерпретации модели можно было бы считать, что графы губковых сетей планарны, т.е. допускают вложение в $RR^2$. Однако, как мы увидим в дальнейшем, такое ограничение является слишком сильным. Пример губковой сети ($"sponge_network"_1$) приведен на @fig:some_sponge_network_1. Верхними вершинами в $"sponge_network"_1$ являются ${(i, 2) | i in #overline[0, 4]}$, а стоковыми ${(i, -1) | i in overline(0"," 4)}$.

#figure(
  caption: [Пример губковой сети $"sponge_network"_1$.],
  generated_image("some_sponge_network/plot.svg")(width: 70%),
) <fig:some_sponge_network_1>

На данном примере можно показать, откуда проистекает название губковых ресурсных сетей. Можно представить, что данный граф моделирует некоторую двухмерную губку с решетчатой внутренней структурой (в данном случае, решетка квадратная). В начальный момент времени на губку капают некоторой жидкостью сверху (на верхние вершины). Затем жидкость просачивается через губку, дотекая до низу, откуда и вытекает из губки (в стоковые вершины). Мы рассматриваем также вариант модели, в которой нет стоковых вершин (например, как на @fig:some_sponge_network_without_sinks_1). Граф "губки" при этом (по крайней мере, если убрать стоковые вершины) является сильно связным. Это сделано для моделирования капиллярного эффекта: жидкость может распространяться из одного кусочка губки во все соприкасающиеся с ним куски, в том числе и вверх.

#figure(
  caption: [Губковая сеть $"sponge_network"_1$, в которой убраны стоки.],
  generated_image("some_sponge_network_without_sinks/plot.svg")(width: 70%),
) <fig:some_sponge_network_without_sinks_1>

#[
  #set text(hyphenate: false)
  Заметим, что веса ребер, идущих "сверху вниз", заметно больше, чем веса ребер, идущих "снизу вверх" ($5 >> 1$), что подкрепляет нашу геометрическую аналогию.
]

Губковая сеть в некотором роде есть продолжение модели распространения загрязнения в водной среде, описанной в @Жилякова2011. В ней распространения загрязнения моделировалось растеканием ресурса в сети, заданной прямоугольной решеткой, в которой пропускные способности соответствовали силе течений и скорости ветра. Губковая сеть, помимо иной интерпретации, отличается большей гибкостью: она включает большее разнообразие топологий, имеет жадные вершины, а также является открытой -- ресурс может втекать сверху и вытекать снизу.

=== Программная реализация

Для исследования свойств губковых сетей, было реализовано соответствующее программное окружение на языке Python. Приложение было названо "sponge-netowrks", оно имеет открытый исходный код, опубликованный на Github @Корешков2023. Лицензия проекта -- MIT.

Основная задача проекта -- предоставить пользователю доступ к надежному, удобному и свободно расширяемому интерфейсу для проведения различных исследований в области ресурсных сетей. Проект интегрирован со средой jupyter notebook, что позволяет получать результаты симуляций и прочих операций над ресурсными сетями в удобно читаемом и интерактивном виде. Sponge-networks позволяет:
- создавать ресурсные сети на основе матриц, графов и списков смежности;
- модифицировать произвольным образом ресурсные сети, не нарушая внутренней целостности данных;
- проводить симуляции, задавая количество шагов, которые должна отработать система, и начальные условия. Результат симуляции хранит в себе всю необходимую информацию о состояниях и потоках сети за время симуляции;
- искать предельные состояния ресурсной цепи, а также положения равновесия эргодической ресурсной сети как цепи Маркова;
- представлять симуляции в виде массивов, листов Excel и графиков;
- рисовать ресурсные сети;
- рисовать симуляции в виде ресурсных сетей с анимациями, реализованными с помощью слайдера, который позволяет визуализировать на граф ресурсной сети в произвольный момент времени (@fig:some_sim_with_slider_1, @fig:some_sim_with_slider_2);
#grid(
  columns: 2,
  align: center,
  [
    #figure(
      caption: [Некоторая сеть в момент времени $t = 0$.],
      image_by_hand("some_sim_with_slider/1.png")(width: 85%),
    ) <fig:some_sim_with_slider_1>
  ],
  [
    #figure(
      caption: [Та же сеть в момент времени $t = 49$.],
      image_by_hand("some_sim_with_slider/2.png")(width: 85%),
    ) <fig:some_sim_with_slider_2>
  ],
)

- экспортировать анимации в gif;
- создавать губковые сети на основе обычных ресурсных сетей и проводить их симуляции;
- создавать губковые сети по шаблону, указывая тип и параметры сетки, а также веса ребер по направлению. Присутствует возможность указать, создавать ли в сети стоки.

=== Типы сеток

Были рассмотрены и реализованы губковые сети не только с квадратной сеткой (как на @fig:some_sponge_network_1), но и с треугольной (@fig:network_types_example_triangular), и с шестиугольной (@fig:network_types_example_hexagonal).

#figure(
  caption: [Пример губковой сети с треугольной сеткой (`n_rows` $= 3$, `n_cols` $= 5$).],
  placement: bottom,
  generated_image("network_types_example/triangular.svg")(width: 55%),
) <fig:network_types_example_triangular>

#figure(
  caption: [Пример губковой сети с шестиугольной сеткой (`n_rows` $= 2$, `n_cols` $= 4$).],
  placement: bottom,
  generated_image("network_types_example/hexagonal.svg")(width: 75%),
) <fig:network_types_example_hexagonal>

Все вышеуказанные сети могут быть построены с помощью функции `build_sponge_network`. Например, сеть на @fig:some_sponge_network_1 была построена так, как приведено на @lst:build_sponge_network_ex[Листинге].
Из приведенного вызова функции можно видеть, какие параметры можно задавать для сети: тип сети `grid_type` (`"grid_2d"` -- квадратная сетка, `"triangular"` -- треугольная, `"hexagonal"` -- шестиугольная); количество "строк" `n_rows`; количество "столбцов" `n_cols`; видимую длину ребер, ведущих в стоковые вершины `visual_sink_edge_length` и особенности сети `layout`. Последний параметр включает в себя описание весов ребер в сети, а также флаг, указывающий, создавать ли стоковые вершины.

#figure(
  caption: [Пример создания губковой сети с помощью функции `build_sponge_network`.],
  // placement: top,
  code(
    ```python
    build_sponge_network(
        grid_type="grid_2d",
        n_cols=4,
        n_rows=3,
        layout={
            "weights_horizontal": 3,
            "weights_up_down": 5,
            "weights_down_up": 1,
            "weights_loop": 1,
            "weights_sink_edge": 1,
            "generate_sinks": True,
        },
        visual_sink_edge_length=0.7,
    )
    ```
  )
) <lst:build_sponge_network_ex>

== Симметричность и асимметричность губковых сетей

Как можно видеть, губковые сети -- в отличие от ресурсных сетей вообще -- имеют довольно симметричную структуру. Попробуем определить более формально, что это означает. Для начала, вслед за Грюнбаумом @Gruenbaum1977, определим замощения плоскости.

#definition[
  Пусть $cal(F)$ -- некоторое разбиение плоскости на измеримые множества ненулевой меры. Назовем $"Sym"(cal(F)) eq.def ("Trans"(RR^2) dot S O(2)) sect {phi in (RR^2 -> RR^2) | forall d in cal(F) sp phi(d) in cal(F)}$ *группой симметрий этого разбиения*, где $"Trans"(RR^2) dot S O(2)$ -- группа движений евклидовой плоскости @Винберг2019[стр. 164]. Иначе говоря, это такой набор движений плоскости (вращений и параллельных переносов), который переводит все множества из $cal(F)$ в (возможно, другие) множества из $cal(F)$. Очевидно, что $"Sym"(cal(F))$ -- группа.
]

#definition[
  *Замощением плоскости* называется разбиение плоскости на множество многоугольников $cal(F)$, при этом "типов" многоугольников -- конечное число, в том смысле что множество, состоящее из орбит всех элементов множества $cal(F)$ под действием группы $"Sym"(cal(F))$ -- иначе говоря, $quo(cal(F),"Sym"(cal(F)))$ -- конечно.
]

#definition[
  Замощение плоскости называется *регулярным*, если группа $"Sym"(cal(F))$ действует на $cal(F)$ транзитивно, т.е. $|quo(cal(F), "Sym"(cal(F)))| = 1$.
]

Известно @Gruenbaum1977, что регулярных замощений плоскости всего 3: прямоугольное, треугольное и шестиугольное.

Пусть $G$ -- бесконечный локально конечный (т.е. $|V| = aleph_0$, но $forall v in V |"adj"(v)| < infinity$, где $"adj"(v)$ -- множество вершин, смежных с $v$) планарный неориентированный граф, а $"emb"(G)$ -- вложение этого графа в плоскость. Скажем, что $G$ определяет разбиение плоскости следующим образом: рассмотрим множество $RR^2 \\ "emb"(G)$. Скажем, что $cal(F)$ есть множество связных компонент $RR^2 \\ "emb"(G)$ (либо же замыканий этих связных компонент, если нам удобно рассматривать множества с границей). Без ограничения общности, можно считать, что $cal(F)$ состоит из многоугольников.

Очевидно, что конкретное разбиение будет зависеть от выбора вложения $G$. Верно также и то, что среди всех вложений $"Emb" = {"emb" | "emb" - #[вложение графа $G$ в плоскость]}$ существуют *максимальные* по насыщенности групповой структуры получившегося разбиения. Иначе говоря, на множестве ${"Sym"(cal(F)(e(G))) | e in "Emb"}$ существует отношение частичного порядка "$<=$", у которого есть максимальные элементы. Здесь $cal(F)(e(G))$ -- разбиение, соответствующее вложению $e$, а группы $H_1$ и $H_2$ связаны отношением $H_1 <= H_2$ если $H_1$ изоморфна некоторой подгруппе $H_2$.

Не задаваясь вопросом о единственности максимального вложения $"emb"$, скажем, что не составит труда привести такие графы и их вложения, чтобы соответствующие им разбиения были треугольным, прямоугольным или шестиугольным замощением плоскости; при этом такие вложения будут максимальными для соответствующих графов. Назовем эти графы и вложения *каноническими*.

Губковые сети, представленные до сих пор, могут быть рассмотрены как подграфы канонических графов для соответствующих регулярных замощений плоскости. Конечно, для проведения такого соответствия $cal(I)$, переводящего ресурсную сеть в подмножество соответствующего разбиения, нужно откинуть веса ребер у губковой сети, а также превратить ее граф из ориентированного в неориентированный. Именно в этом смысле графы губковых сетей являются регулярными. Однако, следует заметить, что сужение $"Sym"(cal(F))$ на образ $cal(I)$ (т.е. $"Im"(cal(I))$) не является группой, так что указанная симметрия замощения на губковые сети не работает.

Сделаем теперь комментарий насчет количества "строк" и "столбцов", характеризующих губковую сеть и указываемых при создании конкретного объекта (как на @lst:build_sponge_network_ex[Листинге]). Считать строки и столбцы следует не по вершинам, а по многоугольникам в $"Im"(cal(I))$. Так, число этих многоугольников равно в точности `n_rows` $dot$ `n_cols`, в чем можно убедиться, взглянув на @fig:network_types_example_triangular и @fig:network_types_example_hexagonal.

Как было сказано выше, губковые сети не обладают симметрией, если их рассматривать как часть замощения плоскости. Однако более продуктивным оказывается рассмотрение их группы симметрий как графов.

#definition[
  Пусть дана некоторая ресурсная сеть $"RN"$. Отображение $Phi : "RN" -> "RN"$ будем называть *автоморфизмом ресурсной сети*, если оно является автоморфизмом графа $G$, соответствующего этой сети, которое сохраняет, при этом, веса ребер, т.е. $forall e in "RN".G.E sp w(e) = w(Phi(e))$, где $w(e)$ -- вес ребра $e$, а также переводит верхние вершины в верхние.

  *Группой автоморфизмов ресурсной сети $"RN"$* назовем множество всех автоморфизмов данной сети $Aut("RN")$, в котором композиция функций выступает в качестве бинарной операции, наделяя указанное множество групповой структурой.
] <def:rn_aut>

#proposition[
  Автоморфизм губковой сети переводит стоковые вершины в стоковые.
] <prop:auto>

Предложение @prop:auto очевидно следует из того, что список смежности вершины является инвариантом графа, а вершины без исходящих ребер все суть стоковые.

Пусть $m in NN$ -- количество столбцов в сети, а $n in NN$ -- количество строк. Будем теперь иметь в виду, что вершины в губковых сетях допускают нумерацию парой натуральных чисел, как демонстрировалось на приведенных выше рисунках. При этом вершина с наименьшими индексами $(x, y)$ находится "слева снизу", а с наибольшими -- "справа сверху". Стоковые вершины нумеруются индексами $(x, -1)$. Верхние вершины в прямоугольной и треугольной сетях обладают индексами $(i, n)$, а в шестиугольных $(i, 2 n + 1)$ (в шестиугольных вершины с индексами $(i, 2 n)$ верхними не являются).

#definition[
  Пусть дана произвольная губковая сеть $"SN"$ (прямоугольная, треугольная или шестиугольная), а $v_1 = (x_1, y_1) in V$ и $v_2 = (x_2, y_2) in V$, при этом $e = (v_1, v_2) in E$. Определим наименования *типов ребер* следующим образом:
  - Ребро $e$ -- *горизонтальное*, если $x_1 != x_2 and y_1 = y_2$;
  - Ребро $e$ -- *"сверху вниз"*, если $y_1 > y_2$;
  - Ребро $e$ -- *"снизу вверх"*, если $y_1 < y_2$;
  - Ребро $e$ -- *петля*, если $v_1 = v_2$.
]

Будем исходить из того, что веса ребер в сети таковы, что:
- все ребра одного типа имеют одинаковые веса;
- вес ребер "сверху вниз" больше, чем вес ребер "снизу вверх".

Данные предположения будем называть *базовыми предположениями о губковой сети*. Все сети, продемонстрированные выше, удовлетворяют этим предположениям.

#theorem[
  Пусть губковая сеть $"SN"$ удовлетворяет базовым предположениям о губковой сети.
  Верно следующее:
  - $"SN"$ обладает осевой симметрией, т.е. $Aut("SN") tilde.equiv quo(ZZ, 2 ZZ)$, если сеть:
    - прямоугольная;
    - шестиугольная, при этом $m$ -- нечетное;
    - треугольная, при этом $m$ -- нечетное и $m > 1$;
  - $Aut("SN") tilde.equiv limits(times.big)_(i = 1)^(ceil(n "/" 2)) quo(ZZ, 2 ZZ)$ если сеть треугольная и $m = 1$;
  - в остальных случаях, сеть не обладает симметрией, т.е. $Aut("SN") tilde.equiv bold(1)$.

  При этом не важно, есть ли в сети стоки или нет.
]<th:sym>

Перед тем, как перейти к доказательству, покажем примеры сетей, о которых идет речь. На @fig:network_types_example_triangular приведен пример треугольной сетки с нечетным количеством столбцов, а на @fig:network_types_example_hexagonal -- шестиугольной с четным. Дополним указанные рисунки треугольной сеткой с четным количеством столбцов (@fig:network_types_example_triangular_sym) и шестиугольной с нечетным (@fig:network_types_example_hexagonal_sym). Также на @fig:network_types_example_triangular_single_sym показан пример треугольной сетки с единственным столбцом.

#grid(columns: 2, align: center + bottom)[
  #figure(
    caption: [Пример губковой сети с треугольной сеткой (`n_rows` $= 2$, `n_cols` $= 4$).],
    generated_image("network_types_example_sym/triangular.svg")(),
  ) <fig:network_types_example_triangular_sym>
][
  #figure(
    caption: [Пример губковой сети с шестиугольной сеткой (`n_rows` $= 2$, `n_cols` $= 3$).],
    generated_image("network_types_example_sym/hexagonal.svg")(),
  ) <fig:network_types_example_hexagonal_sym>
]

#proof[
  #grid(columns: (75%, auto))[
    Пусть $Phi in Aut("SN")$. Разделим наш граф на "уровни" следующим образом. Обозначим за $V_tilde(n)$ множество верхних вершин сети, где $tilde(n) eq.def 2n+1$ если сеть шестиугольная и $tilde(n) eq.def n$ в ином случае. Далее, $V_(tilde(n)-1) eq.def {(j, tilde(n) - 1) | j in NN} sect V$ -- множество всех вершин "предпоследнего уровня". И вообще, определим $V_i eq.def {(j, i) | j in NN} sect V$ вплоть до $V_0$ (или же $V_(-1)$, если в сети есть стоки). Очевидно, $V = limits(union)_i V_i$. Докажем теперь, что $forall V_i  sp Phi(V_i) = V_i$.

    По определению @def:rn_aut, $Phi(V_tilde(n)) = V_tilde(n)$. Предположим, что для некоторого $i$ известно, что $Phi(V_(i+1)) = V_(i+1)$. Рассмотрим произвольное ребро графа $e = (v_1, v_2)$, такое что $v_1 in V_(i+1)$, а $v_2 in V_i$. Поскольку $Phi$ -- автоморфизм, то $Phi(e) = (Phi(v_1), Phi(v_2))$. Мы предположили, что $Phi(v_1) in V_(i+1)$, а значит для ребра $v_2$ в силу специфики рассматриваемых графов есть всего 3 варианта: $Phi(v_2) in V_(i+1)$, или $Phi(v_2) in V_(i+2)$, или $Phi(v_2) in V_i$. Первый вариант невозможен, поскольку тогда получится, что $v_2 in Phi^(-1)(V_(i+1)) = V_(i+1)$, что противоречит определению $V_(i+1)$. По той же причине невозможен и второй вариант. Значит, $Phi(v_2) in V_i$.
  ][
    #figure(
      caption: [Пример губковой сети с треугольной сеткой (`n_rows` $= 5$, `n_cols` $= 1$).],
      generated_image("network_types_example_sym/triangular_single.svg")(),
    ) <fig:network_types_example_triangular_single_sym>
  ]

  В случае треугольной или прямоугольной сетки $V_i subset limits(union)_(v in V_(i+1)) "adj"(v)$, так что отсюда и из доказанного выше автоматически следует, что $Phi(V_i) = V_i$. В шестиугольной сети вершина $(0, 2n)$, а в случае нечетного $m$ еще и вершина $(m, 2n)$, оказываются не связанными с верхним уровнем $V_(2n+1)$. Однако анализа ее (их) списка смежности уже достаточно, чтобы понять, что при автоморфизме она (они) не может (не могут) перейти ни в какие другие вершины, поскольку у нее (них) в соседях единственная вершина на том же уровне и единственная на уровне ниже нее (них), что подразумевает соответствующее распределение взвешенных ребер; при этом эта (эти) вершина(ы) не может (не могут) перейти в верхние, поскольку, по определению, в верхние переходят только верхние. Так что в четном случае $Phi((0, 2n)) = (0, 2n)$, а в нечетном эти вершины переходят либо в себя, либо друг в друга. Таким образом, доказано, что $forall i sp Phi(V_i) = V_i$.

  Оценим теперь, как могут вести себя вершины из $V_i$ под действием $Phi$. Рассмотрим (максимальный) подграф $G_i = "Gen"_(G)(V_i)$ графа $G$, порожденного вершинами $V_i$. В случае прямоугольной или треугольной сетки (и при $m > 1$ в случае треугольной) $G_i$ -- двунаправленная цепь. Ввиду равенства всех весов горизонтальных ребер между собой и всех петель между собой, $G_i$ допускает единственный нетривиальный автоморфизм $S_i$, "разворачивающий" цепь в обратную сторону (по аналогии с отражением $S$ в группе диэдра). Соответственно, $Aut(G_i) = {id_(V_i), S_i}$. Более того, $Phi|_(G_i) in Aut(G_i)$.

  Как ведет себя $Phi$ при попытке "связать" эти пока что независимо рассматривавшиеся части? Всего есть 4 варианта того, как ведет себя $Phi|_("Gen"_(G)(V_(i+1) union V_i))$, а именно:

  $
  Phi|_("Gen"_(G)(V_(i+1) union V_i)) in {
    id, sp id_(V_(i+1)) union.sq S_i, sp S_(i+1) union.sq id_(V_i), sp S_(i+1) union.sq S_(i)
  }.
  $ <nonum>

  Можно убедиться, что четвертый вариант действительно является автоморфизмом на $"Gen"_(G)(V_(i+1) union V_i)$ в прямоугольном случае или в треугольном при нечетном $n$. Если же сеть треугольная и $n$ четно, то степени крайних вершин в $V_i$ при рассмотрении графа $"Gen"_(G)(V_(i+1) union V_i)$ не совпадают, так что такие вершины попросту не могут переходить друг в друга, так что $Aut("SN") tilde.equiv bold(1)$ в случае треугольной сети с четным числом столбцов.

  Второй и третий варианты также не дают нам автоморфизма, поскольку в этом случае под действием $Phi$ рвется связь между, например, вершинами $(0, i+1)$ и $(0, i)$: $((0, i+1), (0, i)) in E$, но $(Phi((0, i+1)), Phi((0, i))) in.not E$. Однако же, если сеть треугольная и в ней присутствует всего один столбец, то наше рассуждение неверно, так как один уровень ($V_(i+1)$ или $V_i$) состоит из единственной вершины (и тогда, конечно, либо $S_(i+1) = id$, либо $S_i = id$) и можно проверить, что тогда $Phi$ действительно автоморфизм на $"Gen"_(G)(V_(i+1) union V_i)$.

  До сих пор мы оставляли в стороне шестиугольные сети. В них $G_i$ является не цепью, а набором из пар взаимно соединенных вершин, либо же некоторыми одиночными вершинами, так что $Aut(G_i)$ достаточно насыщенна. Лучше же рассмотреть $"Gen"_(G)(V_(i+1) union V_i)$. В отличие от прямоугольных и квадратных сетей, здесь этот граф как раз таки и представляет из себя цепь, только веса ребер, не являющихся петлями, здесь не все равны друг другу: присутствуют как горизонтальные ребра, так и "сверху вниз" и "снизу вверх". Отметим, что, по аналогии с рассмотрением сужения $Phi$ на $V_i$, $Phi|_("Gen"_(G)(V_(i+1) union V_i))$ также должна быть автоморфизмом $"Gen"_(G)(V_(i+1) union V_i)$, поскольку $Phi(V_(i+1) union V_i) = V_(i+1) union V_i$.

  Можно заметить, что $Aut("Gen"_(G)(V_(i+1) union V_i)) tilde.equiv bold(1)$ если $m$ четно, так как веса на ребрах крайних вершин цепи оказываются различными. И, наоборот, можно убедиться, что при нечетном $m$ $Aut("Gen"_(G)(V_(i+1) union V_i)) = {id_(V_(i+1) union V_i), S'_i}$, где $S'_i$ -- соответствующее отражение. Попытка "связать" $S'_(i+1)$ и $S'_i$ по аналогии с тем, что мы сделали для прямоугольной или треугольной сети выше, еще быстрее даст нам ответ $Aut(S'_(i+1) union S'_i) = {id, S'_(i+1) union S'_(i)}$, поскольку часть вершин у $"Gen"_(G)(V_(i+2) union V_(i+1))$ и $"Gen"_(G)(V_(i+1) union V_i)$ совпадает, при этом $S'_(i+1)$ и $S'_i$ совпадают на пересечении их областей определения.

  Итак, мы показали, что для всех рассмотренных типов сетей (помимо треугольной сети с одним столбцом) единственный возможный нетривиальный автоморфизм -- отражение. Более того, было показано, что при объединении отражений на разных "уровнях" мы получаем корректно определенное отражение на большем подграфе графа $G$. Естественным образом доказывается, что, проделав подобную процедуру $tilde(n)$ раз, можно получить отражение $S$, определенное корректно на всем графе $G$. Таким образом, доказано, что, помимо случаев, оговоренных выше, $Aut("SN") tilde.equiv quo(ZZ, 2 ZZ)$.

  Рассмотрим теперь случай треугольной сети с одним столбцом. Здесь "склеивание" возможно между различными функциями: как тождественными, так и отражениями. Отражений, при этом, набирается ровно столько, сколько имеется строк с двумя вершинами, а их $ceil(n "/" 2)$. Таким образом, $Aut("SN")$ является прямым произведением групп, сгенерированных отражениями на всевозможных уровнях, т.е. $Aut("SN") tilde.equiv limits(times.big)_(i = 1)^(ceil(n "/" 2)) quo(ZZ, 2 ZZ)$.
]

Наблюдение, касающееся того, какие автоморфизмы может иметь объединение двух графов, можно обобщить с помощью следующего утверждения.

#proposition[
  Пусть $G$ -- произвольный граф (возможно, неориентированный или же с взвешенными ребрами), при этом $V = V_1 union.sq V_2$. Пусть $Aut(G)(V_1) = V_1 and Aut(G)(V_2) = V_2$, т.е. все автоморфизмы графа $G$ переводят вершины из $V_i$ в $V_i$. Определим $tilde(V)_1$ как множество тех вершин из $V_1$, которые смежны с некоторыми вершинами из $V_2$ в графе $G$, т.е. $tilde(V_1) = {v in V_1 | "adj"_G (v) sect V_2 != varnothing}$, аналогичным образом определим $tilde(V)_2$. Пусть $H_1 = Aut("Gen"_G V_1)$, $H_2 = Aut("Gen"_G V_2)$. Тогда выполняется неравенство:

  $
  (limits(sect.big)_(v in tilde(V)_1) Stab_(H_1)(v)) times (
    limits(sect.big)_(v in tilde(V)_2) Stab_(H_2)(v)
  ) <= Aut(G) <= H_1 times H_2,
  $
  где $Stab_H (x)$ -- стабилизатор элемента $x$ при действии группы $H$ на него.
]

#proof[
  #comment[Леееень, как-нибудь потоооом, это же очевиииидно, зачем я это вообще понаписааааал...]
]

В определении автоморфизма сказано о необходимости того, чтобы верхние вершины переходили в верхние при отображении. На самом деле, об этом можно не говорить явно, поскольку это требование автоматически выполняется. По аналогии с тем, как было доказано, что в шестиугольной сети вершины $(0, 2n)$ и $(m, 2n)$ не могут перейти ни в какие другие кроме как друг в друга, здесь можно также проанализировать список смежности верхних вершин и сравнить его с другими вершинами.

Отметим еще одну деталь, касающуюся базовых предположений о губковой сети.

#proposition[
  Предположим, что, в нарушение базовых предположений о губковой сети, веса "сверху вниз" и "снизу вверх" в сети $"SN"$ совпадают. Предположим также, что в сети нет стоковых вершин. Пусть сеть треугольная или прямоугольная и, дополнительно, в случае треугольной сети количество строк четно ($n = 2k$), а в случае прямоугольной $m != n$. В данном случае сеть будет иметь еще один автоморфизм $Phi: Phi((i, j)) = (i, 2 ceil(n "/" 2) - j)$ и, соответственно, $Aut("SN") tilde.equiv quo(ZZ, 2 ZZ)$ в случае треугольной сети и $Aut("SN") tilde.equiv (quo(ZZ, 2 ZZ))^2 = D_2$ (вторая группа диэдра, полная группа симметрий прямоугольника) в случае прямоугольной сети.
]

Очевидно, при этом, что указанная симметрия меняет местами "верх" и "низ" сети. Это выбивается за рамки нашей модели, поэтому и были сформулированы базовые предположения о губковой сети.

== Фактор-сети

До сих пор мы говорили о губковых сетях как о планарных графах. Данное представление, как было показано, довольно сильно ограничивает нас в возможностях использования симметрий для анализа губковых сетей. Попробуем расширить наши возможности, убрав требование планарности и пополнив наш инструментарий таким преобразованием как факторизация.

#definition[
  Пусть $G = (V, E)$ -- некоторый ориентированный граф. Допустим, на множестве вершин $V$ задано произвольное отношение эквивалентности "$~$". Образуем *факторграф графа $G$ по отношению $~$* следующим образом @Gardiner1974. $quo(G, ~) eq.def (V', E'):$

  $
  cases(
      V' = quo(V, ~)";",
      (esq(u), esq(v)) in E' <=> exists u in esq(u)"," exists v in esq(v) : (u, v) in E.
    )
  $ <nonum>
  // , при этом оно конгруэнтно относительно отношения $E$, т.е. сохраняет смежность вершин:
] <def:quotient-graph>

#let ft1 = footnote[
  На самом деле, данная аналогия является точной, если рассматривать описанные примеры как частный случай более общего теоретико-категорного определения понятия фактор-объекта в соответствующей категории. Так, факторграф является фактор-объектом в категории графов, факторгруппа является фактор-объектом в категории групп и т.п. Более подробно о фактор-объектах можно прочитать, например, в классической работе Роберта Голдблатта @Goldblatt2014[глава 4].
]
Интерпретация данного понятия такова: в графе $G$ можно "склеить" некоторые вершины и рассматривать их как одну, при этом "новой" вершине будут смежны все вершины, которые были смежны "старым" вершинам, склеенным в "новую". Можно проводить аналогию #ft1 с факторгруппами, топологическими факторпространствами и др., в которых также некоторые элементы множества отождествляются; только в случае графов никаких дополнительных ограничений на отношение эквивалентности (наподобие конгруэнтности) не требуется.

Понятие факторграфа, однако, применимо лишь к графам в их базовом понимании, а губковая сеть есть в первую очередь взвешенный граф. Если рассмотреть вершины $esq(u)$ и $esq(v)$ из определения @def:quotient-graph, то, в общем случае, может оказаться, что для них существует несколько разных $u$ и $v$, связанных ребрами в исходном графе, при этом эти ребра могут иметь разные веса. Какой будет вес у $(esq(u), esq(v))$? На этот вопрос можно отвечать по-разному. Мы введем сначала операцию, которая позволяет сделать фактор-сеть из любого отношения эквивалентности, а потом рассмотрим ее частный случай, обладающий более интересными свойствами.

// TODO: сделать что-нибудь с D, оно нам вообще надо?
#definition[
  Пусть $"RN"$ -- произвольная ресурсная сеть (возможно, с жадными вершинами), а "$~$", как и в определении @def:quotient-graph, произвольное отношение эквивалентности на вершинах соответствующего графа $G$. Определим *факторизованную ресурсную сеть* (*фактор-сеть*) $quo("RN", ~) eq.def (G', D', S')$ по отношению эквивалентности "$~$" как ресурсную сеть, где:
  // - Граф $G "/" ~$ -- факторграф графа $G$ по отношению $~$;
  // Пусть $u, v in V$ и, соответственно, $esq(u), esq(v) in quo(V, ~)$.
  - Ребра $E'$ и веса $w'$ графа $G'$ определяются следующим образом. $forall esq(u) in quo(V, ~),$ \ $forall esq(v) in quo(V, ~)$:
    - $(exists u in esq(u) : (u, u) in E) <=> (esq(u), esq(u)) in E';$ \ тогда $w'((esq(u), esq(u))) = "avg"{w((u, u)) | (u, u) in E and u in esq(u)}$. Здесь $"avg" X$ есть среднее арифметическое элементов множества чисел $X$;
    - $(exists u in esq(u), exists v in esq(v) : (u, v) in E) <=> (esq(u), esq(v)) in E'$; \ тогда $w'((esq(u), esq(v))) = "avg"{w((u, v)) | (u, v) in E and u in esq(u) and v in esq(v)}$;
  - Функция эволюции динамической системы $S'$ определяется согласно правилам работы ресурсной сети (возможно, с жадными вершинами), соответствущей графу $G'$.
] <def:quotient-network>

Как можно видеть, так же, как и в случае обычного факторграфа, в при факторизации в ресурсной сети не появляется никаких "новых" ребер в том смысле что количество ребер в факторизованной сети не больше, чем в исходной. Отметим также, что данное определение не согласуется с определением обычного ориентированного факторграфа. Действительно, если представить себе некоторый граф $G$ без петель, в котором отождествлены смежные вершины $u$ и $v$, то в $quo(G, ~)$ появится петля $(esq(u), esq(u)) = (esq(v), esq(v))$. Напротив, если представить себе подобную ситуацию с ресурсной сетью $"RN"$, то новых петель в ходе факторизации не появится. Такая разница введена для того, чтобы различить разные по своей сути классы ребер в ресурсной сети с жадными вершинами: петли и все остальные ребра. Действительно, если бы мы разрешили отождествлять вершины без петель так, чтобы в результате получалась "жадная" вершина, это бы заметно изменило качественные свойства сети. Впрочем, мы будем рассматривать несколько иные ситуации, подпадающие под определение @def:ideal-quotient.

#definition[
  Пусть $"RN"$ -- произвольная ресурсная сеть (возможно, с жадными вершинами). Отношение эквивалентности на множестве вершин сети "$~$" назовем *идеальным* (и, соответственно, получившуюся фактор-сеть $quo("RN", ~)$ назовем *идеально факторизованной*), если $forall esq(u) in quo(V, ~)$, $forall esq(v) in quo(V, ~)$ выполняются следующие условия:
  - $forall u', u'' in esq(u) sp ((u', u') in E and (u'', u'') in E and w((u', u')) = w((u'', u'')))$;
  - $forall u', u'' in esq(u), forall v', v'' in esq(v) ((u', v') in E and (u'', v'') in E => w((u', v')) = w((u'', v'')))$.

  Иначе говоря, всякий раз, когда в определении @def:quotient-network встречается выражение $"avg" X$ для некоторого $X$, $X$ есть одноэлементное множество.
] <def:ideal-quotient>

Если сеть факторизуется идеально, то вопрос о том, что делать с разными весами ребер, ведущих в отождествляющиеся вершины, снимается: все такие ребра имеют одинаковые веса. Такие факторизации будут представлять для нас основной интерес, поскольку они менее всех искажают симметрии, присутствующие в графе.

#proposition[
  Пусть $J = {esq(v) | esq(v) in quo(V, ~) and abs(esq(v)) > 1 }$. Тогда если $forall esq(u) in J, forall esq(v) in J : esq(u) != esq(v) sp (forall u' in esq(u), forall v' in esq(v) sp "adj"_(G)(u') sect "adj"_(G)(v') = varnothing)$, то выполнено второе условие из определения @def:quotient-network. Если, дополнительно, веса петель в каждом классе эквивалентности равны, то $quo("RN", ~)$ факторизуется идеально.
] <prop:simple_ideal>

Доказательство данного факта провести несложно: стоит заметить, что при выполнении условия из предложения @prop:simple_ideal в исходном графе $G$ не окажется никакой пары ребер, ведущих из одного общего класса эквивалентности в другой общий класс эквивалентности, а значит условие на равенство весов ребер будет выполнено автоматически.

// cspell:disable-next-line
В качестве примера рассмотрим губковую сеть $"qn"_1$ ("$"qn"$" -- #strong[q]uotient #strong[n]etwork) с 2 строками и 4 столбцами с треугольной сеткой. Определим отношение эквивалентности на множестве вершин сети следующим образом. Отождествим 2 вершины, не имеющие общих смежных вершин, например, вершины $(0, 1)$ и $(3, 0)$, а остальные будут эквивалентны только себе. Для наглядности будем говорить об одноэлементных множествах сети как о самих элементах этих множеств. Так, вместо того, чтобы писать "${(0, 2)} in quo(V, ~)$", будем писать "$(0, 2) in quo(V, ~)$".

На @fig:qn_1_1 приведена данная сеть с начальным состоянием $q_0$ = #state_dict(("(0, 2)": 0, "(1, 2)": 30, "(2, 2)": 0, "(3, 2)": 0)) (остальные вершины имеют нулевое начальное состояние). Отождествленные вершины обведены красным. Данный рисунок является условным, поскольку никаких двух вершин в графе на самом деле нет, равно как и ребер, соединяющих эти вершины с другими. Такой способ изображения выбран потому, что в результате факторизации получившийся граф может не быть планарным, так что выбрать наглядное представление соответствующей сети может быть затруднительно. При данном способе отображения состояние "разделяется" отождествленными вершинами. На @fig:qn_1_2 показано состояние $"qn"_1$ в следующий момент времени. Вершина ${(0, 1), (3, 0)}$ содержит 5 единиц ресурса, так что на рисунке обе "вершины" содержат по 5 единиц ресурса.

#grid(columns: 2, align: center + top)[
  #figure(
    caption: [Пример фактор-сети в момент времени $t = 0$.],
    generated_image("qn_1/1.svg")(),
  ) <fig:qn_1_1>
][
  #figure(
    caption: [Та же сеть в момент времени $t = 1$.],
    generated_image("qn_1/2.svg")(),
  ) <fig:qn_1_2>
]

Поскольку в рассмотренной сети выполняются условия предложения @prop:simple_ideal, то полученная факторизация сети идеальна. С точки зрения выбранного нами способа изображения это значит, что веса ребер на рисунке не меняются по сравнению с сетью до факторизации. Так, в исходной сети ребро $((1, 2), (0, 1))$ имело вес 5, значит и ребро $((1, 2), {(0, 1), (3, 0)})$ имеет вес 5, поэтому на приведенных рисунках соответствующее ребро имеет также вес 5.

// Приведенное в предложении @prop:simple_ideal условие идеальной факторизации просто, но не вполне покрывает наши потребности. Сформулируем более сильное утверждение.

// #proposition[

// ]

== Губковые сети на цилиндре

#let eqcyl = $~_("cyl")$

Пусть дана некоторая сеть $"SN"$, удовлетворяющая базовым предположениям о губковой сети. Пусть $tilde(m) = m$, если сеть прямоугольная или шестиугольная и $tilde(m) = floor(m "/" 2)$, если сеть треугольная.
// Дополнительно, пусть $m$ -- четно, если сеть треугольная и шестиугольная.
Рассмотрим следующее отношение эквивалентности $eqcyl$ на множестве вершин сети $V$:
$
u sp eqcyl v <=> cases(delim: "[",
    u = v\,,
    j_1 = j_2 and (i_1\, i_2 in {0, tilde(m)})\, #[где] (i_1, j_1) = u\, (i_2, j_2) = v.
  )
$

Будем называть $quo("SN", eqcyl)$ *губковой сетью на цилиндре*. Приведенную факторизацию можно рассматривать как помещение губковой сети на цилиндр: левый и правый края сети "склеиваются" в одну линию. Пример такой сети приведен на @fig:sn_on_cylinder_1. Как и прежде, вершины, которые были отождествлены (с какими-либо другими вершинами) обведены красным. Подчеркнем, что классов эквивалентности с числом элементов $> 1$ не 1, а 4: ${(0, 2), (3, 2)}$, ${(0, 1), (3, 1)}$, ${(0, 0), (3, 0)}$ и, наконец ${(0, -1), (3, -1)}$.

#figure(
  caption: [Губковая сеть с треугольной стекой, помещенная на цилиндр.],
  // placement: bottom,
  generated_image("cylinder_triangular_1/plot.svg")(width: 75%)
) <fig:sn_on_cylinder_1>

#lemma[
  Губковая сеть $quo("SN", eqcyl)$ факторизована идеально, если она удовлетворяет базовым предположениям о губковой сети.
] <lem:ideal_cylinder>

Для доказательства данной леммы воспользуемся следующим фактом.

#lemma[
  Пусть $"RN"$ -- произвольная ресурсная сеть, а $~$ -- такое отношение эквивалентности на $V$, что сеть $quo("RN", ~)$ факторизована идеально. Пусть также внутри одного класса эквивалентности:

  - совпадают веса всех ребер, т.е. $forall esq(u) in quo(V, ~) sp forall u_1, u_2, u'_1, u'_2 in esq(u) : u_1 != u_2  and u'_1 != u'_2 sp ((u_1, u_2) in E and (u'_1, u'_2) in E => w((u_1, v_1)) = w((u'_1, u'_2)))$;
  - совпадают веса всех петель.

  В таком случае, любое измельчение разбиения $quo(V, ~)$ также факторизует сеть идеально. Под измельчением мы понимаем такое отношение эквивалентности $~'$ на $V$, что $u ~' v => u ~ v$.
] <lem:subpartition>

#proof[
  #let esqt = esq.with(eqv_rel: $~'$)
  Рассмотрим произвольные классы $esqt(u)$ и $esqt(v)$ и произвольные вершины внутри этих классов $u', u'' in esqt(u)$, $v', v'' in esqt(v)$.

  - Поскольку веса всех петель внутри $esq(u)$ и $esq(v)$ совпадали, то совпадут они и на любом подмножестве $esq(u)$ и $esq(v)$ соответственно, в частности, на $esqt(u)$ и $esqt(v)$.
  - Рассмотрим теперь ребра $(u', v')$ и $(u'', v'')$, полагая, что $u' != v' and u'' != v''$, а $esqt(u) != esqt(v)$.
    - Если $esq(u) != esq(v)$, то $w((u', v')) = w((u'', v''))$ в силу определения @def:ideal-quotient, примененного к отношению $~$.
    - Положим, что $esq(u) = esq(v)$. Тогда $w((u', v')) = w((u'', v''))$ в силу условия леммы.

  Таким образом, все требования для идеальной факторизации сети $quo("RN", ~')$ выполнены.
]

#proof[леммы @lem:ideal_cylinder][
  #let eqlev = $~_"level"$
  Рассмотрим отношение эквивалентности $eqlev$, которое отождествляет все вершины уровня $V_i$ между собой, т.е. $(i_1, j_1) sp eqlev (i_2, j_2) <=> j_1 = j_2$. С одной стороны, все ребра, связывающие классы эквивалентности по $eqlev$ являются ребрами одного типа одновременно: либо "сверху вниз", либо "снизу вверх". С другой стороны, все ребра внутри одного уровня -- горизонтальные. Учитывая вышесказанное, заключим, что если сеть удовлетворяет базовым предположениям о губковой сети, то выполняются условия леммы @lem:subpartition. Очевидно, что отношение $eqcyl$ является измельчением разбиения $eqlev$, а значит, $quo("SN", eqcyl)$ факторизуется идеально.
]

// Помещение сети на цилиндр может быть и проинтерпретировано с помощью замощений плоскости. Положим,

// Очевидно, что помещение

Отметим, что у сети с треугольной сеткой на @fig:sn_on_cylinder_1 число столбцов до факторизации было четным. Для сравнения приведем сеть с треугольной сеткой и нечетным количеством столбцов (@fig:sn_on_cylinder_bad). Может показаться, что -- в отличие от случая с исходной сетью -- сеть на @fig:sn_on_cylinder_1 более симметрична, чем сеть на @fig:sn_on_cylinder_bad. Действительно, это так.

// Если сеть прямоугольная, или же если она треугольная или шестиугольная, но число столбцов в ней четно, то будем говорить, что такая сеть *поме*. Пример фактор-сети с треугольной сеткой, которая поме, приведен на @fig:sn_on_cylinder_1. Для сравнения, на

// Будучи помещенной на цилиндр, губковая сеть теперь обладает большим количеством симметрий.

#figure(
  caption: [Губковая сеть с треугольной стекой и нечетным числом столбцов на цилиндре.],
  generated_image("cylinder_triangular_2/plot.svg")(width: 55%),
) <fig:sn_on_cylinder_bad>

#theorem[
  Пусть $"SN"$ -- губковая сеть с числом столбцов $m > 1$. Пусть также, снова, $tilde(m) = m$, если сеть прямоугольная или шестиугольная и $tilde(m) = floor(m "/" 2)$, если сеть треугольная.

  - Если сеть прямоугольная, то $Aut(quo("SN", eqcyl)) tilde.equiv D_(tilde(m) - 1)$, где $D_k$ -- $k$-ая группа диэдра.
  - Если сеть треугольная или шестиугольная, а количество столбцов четно, то $Aut(quo("SN", eqcyl)) tilde.equiv D_(tilde(m) - 1)$.
  - Если сеть треугольная или шестиугольная, но количество столбцов нечетно, то $Aut(quo("SN", eqcyl)) tilde.equiv quo(ZZ, 2 ZZ)$.

] <th:cylinder-sym>

#proof[
  Наша логика будет во многом повторять ту, что использовалась в теореме @th:sym. Для начала, предположим, что сеть прямоугольная или же треугольная с четным количеством столбцов. Рассмотрим снова уровни $V_i$ сети $quo("SN", eqcyl)$. На сей раз $"Gen"_G V_i$ представляют из себя не простые пути, а простые циклы на $tilde(m) - 1$ вершине.

  // TODO: закончить
  #comment[Закончить доказательство]
]

Дополнительно был доказан следующий факт:

#proposition[
  Графы губковых сетей, помещенных на цилиндр, планарны.
]

== Связь с динамическими системами

#definition[
  Пусть дано произвольное множество $X$ и некоторая функция $S: X -> X$. *Дискретная динамическая система* $cal(S) eq.def (X, S)$ может быть образована из $S$ следующим образом: если $q(0) in X$ -- некотрое начальное состояние, то $q(t) = S(q(t-1)), t in NN$. $S$ при этом называется *функцией эволюции динамической системы*.
]

#definition[
  Пусть $cal(S)_1 = (X_1, S_1)$ и $ cal(S)_2 = (X_2, S_2)$ -- две динамические системы. Отображение $Phi : X_1 -> X_2$ называется *морфизмом* между $cal(S)_1$ и $cal(S)_2$, если $forall x in X_1 sp Phi(S_1(x)) = S_2(Phi(x))$.

  Отображение $Phi$ называется *изоморфизмом*, если оно биективно.

  Изоморфизм $Phi$ называется *автоморфизмом*, если оно изоморфизм и $cal(S)_1 = cal(S)_2$, т.е. автоморфизм -- это изоморфизм "на себя".
] <def:dyn_syst_aut>

Мы хотели бы связать симметрии ресурсных сетей как графов с некоторым симметричным поведением их как динамических систем. Симметричность поведения динамических систем и выражается понятием автоморфизма. Автоморфизм передает всю полноту информации о динамической системе.

В качестве примера системы обладающей симметрией, можно привести следующую: $S: RR -> RR$:

$ S(x) = a_1 x + a_2 x^3, sp sp a_1, a_2 in RR. $ <eq:dyn-auto-ex1>

У данной системы присутствует следующий автоморфизм: $Phi(x) = -x$. Действительно,

$ forall x in RR sp S(Phi(x)) = S(-x) = a_1 (-x) + a_2 (-x)^3 = - (a_1 x + a_2 x^3) = Phi(S(x)). $ <nonum>

Если динамическая система обладает нетривиальным автоморфизмом, то между фазовыми траекториями существует некоторая биекция, сохраняющая свойства этих траекторий. Так, траектория, полученная из начального состояния $3$ системы @eq:dyn-auto-ex1 обладает теми же свойствами, что и траектория, начинающаяся из начального состояния $-3$ -- разница лишь в знаке. Положим, нам интересно рассмотреть множество всех возможных траекторий данной системы. Для этого стоило бы взять всевозможные начальные состояния $q^0 in RR$ и затем строить $S(q^0), S^2(q^0), ...$. Благодаря наличию симметрии $Phi$ можно сузить множество рассматриваемых состояний до $RR_+$.

Схожие рассуждения применимы и к ресурсным сетям. Можно смотреть на ресурсные сети как на отображения $S : RR_+^nu -> RR_+^nu$, где $nu$ -- количество вершин в сети. В установлении того, какие симметрии наличествуют у ресурсных сетей помогает следующая теорема.

#theorem[
  Пусть $"RN"$ -- ресурсная сеть с $nu$ вершинами. Будем считать, что в сети зафиксирована некоторая нумерация вершин, т.е. $V = {v_i}_(i = 1)^nu$. Пусть $Phi$ -- автоморфизм $"RN"$ как графа (определение @def:rn_aut). В таком случае $Phi$ индуцирует ее автоморфизм $Phi' : RR_+^nu -> RR_+^nu$ как динамической системы следующим образом: $forall q in RR_+^nu sp Phi'(q)_i eq.def q_j$, где $j : Phi(v_j) = v_i$.
] <th:rn_sym_with_dyn>

#proof[
  Отметим, сначала, что отображение $Phi'$ определено корректно, поскольку $Phi$ -- биекция на множестве вершин графа. Далее, заметим, что любой автоморфизм графа индуцирует некоторую перестановку его вершин. Назовем ее $sigma$, тогда $sigma(i) eq.def j : Phi(v_i) = v_j $.

  // Пусть граф исходной сети -- $G$, тогда скажем, что граф сети, полученной после перенумерации вершин, есть $G_"perm"$. Применив перестановку $sigma$ к строкам и столбцам матрицы смежности $R$ получим матрицу смежности $sigma(R)$ графа $G_"perm"$. Поскольку стохастическую матрицу от матрицы пропускной способности отличает лишь сумма элементов каждой строки, то стохастическая матрица $G_"perm"$ есть $R'_"perm" = sigma(R')$.

  Для произвольного вектора $v$ будем обозначать соответствующую перестановку его элементов за $sigma(v)$, для произвольной матрицы $A$ будем обозначать одновременную перестановку ее строк и столбцов снова за $sigma(A)$. Можно доказать, что для произвольных векторов $v_1, v_2 in RR^(nu times 1)$, матриц $A, B in RR^(nu times nu)$ верно:

  - $sigma(v_1^T v_2) = sigma(v_1)^T sigma(v_2)$;
  - $sigma(A v_1) = sigma(A) sigma(v_1)$;
  - $sigma(A B) = sigma(A) sigma(B)$;
  - $sigma(v_1 + v_2) = sigma(v_1) + sigma(v_2)$;
  - $sigma(A dot.circle B) = sigma(A) dot.circle sigma(B)$;
  - $sigma(min{A, B}) = min{sigma(A), sigma(B)}$.

  В таком случае, для произвольного состояния системы $q$, с использованием определения @def:flow-matrix, получим:

  $
  sigma(F(q)) = sigma(min{R' dot.circle (bold(1) dot q), R}) = min{
    sigma(R') dot.circle (bold(1) dot sigma(q)), sigma(R)
  }.
  $ <nonum>

  Поскольку $Phi$ -- автоморфизм графа, то перестановка $sigma$ оставляет на месте матрицу смежности графа, т.е. $sigma(R) = R$. Более того, поскольку стохастическая матрица является функцией только матрицы смежности, то $sigma(R') = R'$. Тогда

  $
  sigma(F(q)) = min{sigma(R') dot.circle (bold(1) dot sigma(q)), sigma(R)} = min{
    R' dot.circle (bold(1) dot sigma(q)), R
  } = F(sigma(q)).
  $ <nonum>

  Используем теперь формулу для функции эволюции ресурсной сети @eq:S:

  $
  sigma(S(q)) = sigma(q - (F(q) dot bold(1))^T + bold(1)^T dot F(q)) =\
  = sigma(q) - (F(sigma(q)) dot bold(1)^T + bold(1)^T dot F(sigma(q))) = S(sigma(q)).
  $ <nonum>

  Последняя формула и является переформулировкой искомого. Таким образом, согласно определению @def:dyn_syst_aut, теорема доказана.

  // матрицы смежности $R$ (обозначим ее $Phi(R)$), при этом $Phi(R)$ является (взвешенной) матрицей смежности графа, полученного перенумерацией вершин, соответствующей $Phi$.
]

Обозначим группу автоморфизмов ресурсной сети $"RN"$ как графа $Aut_"graph" ("RN")$, а группу автоморфизмов ее как динамической системы -- $Aut_"dyn" ("RN")$.

#corollary[
  Для произвольной ресурсной сети $"RN"$ верно

  $ Aut_"graph" ("RN") <= Aut_"dyn" ("RN"). $ <nonum>
]

#remark[
  Из вышесказанного еще не следует, что симметрии ресурсной сети как динамической системы ограничиваются симметриями соответствующего графа. Для получения ответа на этот вопрос требуется проведение дополнительного исследования.
]

Все наши рассуждения, проведенные для ресурсной сети, верны и для ресурсной сети с жадными вершинами, и для губковой сети. Благодаря этому мы можем получить занимательные результаты, касающиеся поведения губковых сетей. Для того, чтобы продемонстрировать практическую ценность наших результатов, докажем небольшое вспомогательное утверждение.

#proposition[
  Пусть дана произвольная динамическая система $cal(S) = (X, S)$, $Aut(cal(S))$ -- группа ее автоморфизмов, $x in X$ -- произвольное состояние, а $Stab(x)$ -- стабилизатор состояния $x$ относительно действия группы $Aut(cal(S))$ на $X$, т.е. $Stab(x) = {Phi in Aut(cal(S)) | Phi(x) = x}$. Тогда $forall n in NN sp Stab(x) subset Stab(S^n (x))$. Иначе говоря, траектория, соответствующая начальному состоянию $x$ является целиком "самосимметричной", если начальное состояние было "самосимметричным".
] <prop:sym_traj>

#proof[
  Возьмем произвольную $Phi in Stab(x)$, тогда $Phi(S(x)) = S(Phi(x)) = S(x)$, значит $Stab(x) subset Stab(S(x))$. Аналогичным образом доказывается, что $Stab(S(x)) subset Stab(S^2 (x))$. И вообще, по индукции доказывается $forall n in NN sp Stab(S^n (x)) subset Stab(S^(n+1) (x))$, из чего и следует искомое.

]
// С другой стороны, если $Phi in Stab(S(x))$, то $Phi(S(x)) = S(x)$ и одновременно $Phi(S(x)) = S(Phi(x))$, следовательно $$

#remark[
  Заметим, что обратное включение в предложении @prop:sym_traj, в общем случае, неверно. Это зависит от того, является ли $S$ биекцией. В литературе по эргодической теории (например, в @Walters2000) в определении динамической системы требуется, чтобы $S$ была биекцией. К сожалению, функция эволюции ресурсной сети не является биективной. Более того, она не является сюръективной. Например, в сети на @fig:basic_network_1 невозможно указать состояние, при действии на которое функции $S$ получится $(10, 0, 0)$. В некоторых случаях $S$ не является и инъективной. Например, в некоторой окрестности нуля функция $S$ линейна, но при этом возможны такие топологии графа ресурсной сети, что стохастическая матрица оказывается вырожденной. Тогда $S$ будет неинъективна.

  // #figure(
  //   caption: [Ресурсная сеть, функция эволюции которой не является инъективной.],
  //   generated_image("noninjective_network/plot.svg")(width: 35%)
  // ) <fig:noninjective_network>
]

#pagebreak()

В качестве примера, когда стабилизатор "расширяется" под действием $S$, приведем следующую динамическую систему $cal(S)$. Пусть $X$ -- множество конечных последовательностей из натуральных чисел. Например, $(1, 4, 2) in X$ или же $(3, 3, 7, 4, 5) in X$. Пусть $S$ "забывает" последний элемент последовательности, то есть $S : (x_1, x_2, ..., x_(n-1), x_n) arrow.bar (x_1, x_2, ..., x_(n-1))$, а $S((x_1)) = (x_1)$. Можно показать, что любой автоморфизм $Phi$ данной динамической системы однозначно определяется набором функций ${f_i}_(i = 1)^infinity$, где $f_i : NN^i -> NN$, а $Phi : (x_1, x_2, ..., x_n) |-> (f_1 (x_1), f_2 (x_1, x_2), ..., f_n (x_1, ..., x_n))$. Рассмотрим произвольный элемент $a in X, a = (a_1, ..., a_k)$. Каждый автоморфизм $Phi_a in Stab(a)$ характеризуется тем, что для него $forall i in overline(1\, k) sp f_i (a_1, ..., a_i) = a_i$, дополнительных ограничений на $f_i$ не накладывается. Образ $a$ под действием $S$ суть $S(a) = (a_1, ..., a_(k-1))$. Повторяя приведенные выше рассуждения получим, что $Phi_S(a) in Stab(S(a)) : forall i in overline(1\, k-1) sp f_i (a_1, ..., a_i) = a_i$. Очевидно, что $exists Phi in Stab(S(a)) : Phi in.not Stab(a)$, например $Phi : (x_1, ..., x_(k-1), x_k, ..., x_n) |-> (x_1, ..., x_(k-1), phi(x_k), ..., x_n)$, где $phi$ -- некоторая нетривиальная биекция $NN$ в себя $: phi(a_k) != a_k$. Более того, $Stab(a) subset Stab(S(a)) subset ... subset Stab(S^(k-1) (a))$, и здесь все включения являются строгими. Можно также видоизменить данный пример так, чтобы образовывалась бесконечная все расширяющаяся цепочка $Stab(a) subset Stab(S(a)) subset ...$ и чтобы

$ limits(union.big)_(i=0)^infinity Stab(S^i (a)) = Aut(cal(S)). $ <nonum>

// необходимо оставляет на месте первые $k$ элементов последовательности, на которую действует, имея, таким образом, вид $Phi_a (x) : (x_1, ..., x_k, x_(k+1), ..., x_n) |-> (x_1, ..., x_k)$

Несмотря на сказанное выше, мы вполне удовлетворимся полученным результатом, поскольку анализ полной группы симметрий ресурсных сетей все равно выходит за рамки наших возможностей.

#remark[
  Покуда это не вызовет недопониманий, будем говорить о группе $Aut_"graph" ("RN")$ одновременно и как о действующей на граф сети, и как о действующей на динамическую систему.
]

#[
  #let state = state_dict(("(0, 2)": 8, "(1, 2)": 20, "(2, 2)": 0, "(3, 2)": 20, "(4, 2)": 8))

  Приведем теперь пример такой сети $"SN"$ и такого состояния $q^0$, что $Stab(q^0) != {id}$ (@fig:sponge_symmetrical_sim). Здесь $q^0 = state$.

  #figure(
    caption: [Некоторая губковая сеть и ее начальное состояние $q^0 = state$.],
    generated_image("sponge_symmetrical_sim/1.svg")(width: 70%),
  ) <fig:sponge_symmetrical_sim>

  Согласно теореме @th:sym, $Aut_("graph")("SN") = {id, "flip"},$ где $"flip"$ -- отражение сети вдоль вертикальной оси. Несложно видеть, что $q^0$ является самосимметричным в том смысле, что $Stab(q^0) = Aut_("graph")("SN")$. Исходя из предложения @prop:sym_traj, данная симметрия сохранится и под действием динамической системы в дальнейшем. Так, на @fig:sponge_symmetrical_sim_2 приведено состояние сети после действия на $q^0$ системы $S$ 4 раза, т.е. в момент времени $t = 4$. Можно видеть, что симметрия сохранилась.

  #figure(
    caption: [Та же губковая сеть, состояние в момент времени $t = 4$.],
    generated_image("sponge_symmetrical_sim/2.svg")(width: 70%),
  ) <fig:sponge_symmetrical_sim_2>

]

#let state = state_dict(("{(0, 3), (6, 3)}": 12, "(1, 3)": 0, "(2, 3)": 12, "(3, 3)": 0, "(4, 3)": 12, "(5, 3)": 0))

Обыкновенные губковые сети, как было сказано, обладают довольно небольшим количеством симметрий. Более интересные результаты можно получить, если рассмотреть губковые сети на цилиндре. На @fig:sponge_symmetrical_2_sim_1 приведен пример такой сети с прямоугольной сеткой и начальным состоянием

$ q^0 = #state. $ <nonum>

В данном случае стабилизатор порождается отражением (любым) и поворотом цилиндра на $pi\/3$, т.е. смещением всех вершин сети на 2 позиции вправо.

#figure(
  caption: [Начальное состояние губковой сети на цилиндре.],
  generated_image("sponge_symmetrical_2_sim/1.svg")(width: 70%),
) <fig:sponge_symmetrical_2_sim_1>

На @fig:sponge_symmetrical_2_sim_1 показана сеть в момент времени $t = 3$. Можно видеть, что у состояния тот же стабилизатор.

#figure(
  caption: [Та же губковая сеть, состояние в момент времени $t = 3$.],
  generated_image("sponge_symmetrical_2_sim/2.svg")(width: 70%),
) <fig:sponge_symmetrical_2_sim_2>

= ЗАКЛЮЧЕНИЕ <nonum>

Нами были исследованы симметрии губковых сетей и связи между автоморфизмами графов и динамических систем ресурсных сетей, порождающихся этими графами. С одной стороны, мы установили, что несмотря на регулярность, губковые сети теряют много своих симметрий относительно замощений плоскости, их порождающих. Вместе с тем было дано полное описание групп автоморфизмов губковых сетей (в том числе и в случае, когда "верх" и "низ" симметричны друг относительно друга). Было введено понятие факторизации ресурсных сетей и исследованы базовые ее свойства: в каких ситуациях сеть факторизуется идеально, а в каких нет? С помощью факторизации мы смогли из обыкновенных губковых сетей строить губковые сети на цилиндре, обладающие намного большим набором симметрий. Группы автоморфизмов таких сетей также были описаны полностью. Наконец, мы установили, что каждая симметрия графа ресурсной сети порождает симметрию ее как динамической системы. Полученные утверждения можно применять для облегчения моделирования и уменьшения размера анализируемой сети.

Проведенное исследование открывает широкий простор для дальнейших изысканий. С одной стороны, можно ставить вопросы о протекании ресурса через губковую сеть, например:

- При данных параметрах сети (столбцы, строки, вес всех типов ребер), каково минимальное количество ресурса, которое может быть помещено в верхние вершины так, чтобы ресурс дотек до стоковых вершин? Каково должно быть распределение этого ресурса?
- При данном начальном распределении ресурса в верхних вершинах, какую форму будет иметь "след" данного ресурса в пределе, если ресурса не хватит на то, чтобы покрыть все "потребности" жадных вершин? Какова зависимость ширины и глубины следа от параметров сети?

С другой стороны, можно исследовать возможность обобщения полученных результатов с губковых сетей на более общие динамические модели на графах, для которых симметрии графа и динамической системы будут соотноситься так же, как и в случае ресурсных сетей. Вероятно, можно найти такое обобщение, под которое подпадут и цепи Маркова, и ресурсные сети, и другие модели, в которых состояние вершины в следующий момент времени зависит лишь от текущего ее состояния и состояния всех смежных с ней вершин.

//  функционирование губковых сетей с

// TODO:
// - сослаться на монографию а не на работу 2013 года ЖИЛЯКОВА РЕСУРСНЫЕ СЕТИ...
#bibliography(
  "../literature/sn_literature.bib",
  title: [Список использованных источников],
  style: "../literature/gost-r-7-0-5-2008-numeric.csl",
)
