#import "./template.typ": thmrules, template, definition, theorem, proof, claim, code, lemma, corollary, remark, turn-on-first-line-indentation as fli

#let sp = h(0.5em)

#let state_dict(d) = {
  // assert(type(d) == dictionary)
  ${#(d
    .pairs()
    .map(((k, v)) => $bold(#(k+":")) #v$)
    .join(",")
    )}$
}

#let generated_image(subpath) = {
  // assert(type(subpath) == str)
  (..args) => image("../assets/generated/" + subpath, ..args)
}

#let image_by_hand(subpath) = {
  // assert(type(subpath) == str)
  (..args) => image("../assets/images/" + subpath, ..args)
}

#let varnothing = $text(font: "Fira Sans", nothing)$

#let comment(cnt) = text(fill: red, cnt)

#let quo(l, r) = {
  $#l"/"#r$
}
#let esq(u, eqv_rel: none) = $[#u]_#( if eqv_rel == none {"~"} else {eqv_rel})$

#let Stab = $"Stab"$
#let Aut = $"Aut"$

#show: thmrules
#show: template

////////////////////////
// Document begins!
////////////////////////
#outline(title: [Содержание])

= ВВЕДЕНИЕ <nonum>

Многие проблемы из разных предметных областей формулируются и решаются с использованием сетевых моделей. Изучение различных динамических процессов в сетях, как стохастических, так и детерминированных, часто требует инструментов однородных и неоднородных цепей Маркова. Работа была посвящена исследованию модели ресурсной сети с особым видом топологии графа. Проблема изучения ресурсных сетей относится к пересечению нескольких классов диффузионных моделей. Первый содержит различные модели случайного блуждания \[1\]. Это большое поле, включающее случайные блуждания по решеткам \[2\], по конечносвязным неориентированным графам \[3\], случайные блуждания с локальными смещениями \[4\] и т.д. В \[5\] задачи оптимизации потоков и нахождения кратчайших путей были решены с использованием анализа функций большого отклонения случайных блужданий. Нелинейная диффузия рассматривалась в \[6\]. Нелинейность представляет для нас особый интерес, поскольку модель ресурсной сети, также, в общем, нелинейна. Это достигается за счет порогового переключения между правилами работы вершин. Некоторые вершины при определенных условиях переключаются на нелинейное правило и начинают функционировать аналогично вершинам в модели игры с выбиванием фишек (chip-firing). Эта модель была предложена довольно давно \[7\], однако она не утратила своей актуальности и в настоящее время \[8-10\]. Игра с выбрасыванием фишек часто используется для описания модели песчаной кучи или лавины \[11\] и аналогичных процессов самоорганизующейся критичности \[12–16\].

В дополнение к описанию физических процессов распространения в сетях, аналогичные модели появляются при моделировании информационных процессов, в частности, динамики мнений и достижение консенсуса в многоагентных системах. В настоящее время классическая модель DeGroot \[17\] имеет множество различных модификаций \[18-21\]. Однородные и неоднородные цепи Маркова являются одним из основных инструментов для описания систем, процессов и устройств с несколькими состояниями \[22,23\].

Модель ресурсной сети представляет собой нелинейную диффузионную модель, в которой по вершинам ориентированного взвешенного графа распределяется некоторый безразмерный бесконечно разделимый ресурс в соответствии с двумя правилами в зависимости от количества ресурса на каждом временном шаге. Время в модели дискретно; все вершины работают параллельно. Веса ребер обозначают их пропускную способность. Вершины могут хранить неограниченное количество ресурсов. Если в момент времени t объем ресурсов в вершине превышает общую пропускную способность ее исходящих дуг, эта вершина отправляет полную пропускную способность по каждой дуге; в противном случае он выдает весь свой ресурс, деля его пропорционально пропускной способности дуг. Нелинейность возникает в модели, когда общий ресурс превышает пороговое значение, из-за чего разные вершины сети начинают функционировать в соответствии с разными правилами.

Ресурсная сеть была впервые предложена в \[27\]. С тех пор возникла теория ресурсных сетей, и краткое описание можно найти в \[28\]. В этой статье также описываются две двухпороговые модификации стандартной модели. Некоторые другие модели, основанные на стандартной сети ресурсов, были разработаны другими исследовательскими группами \[29,30\].

= ОСНОВНЫЕ ПОНЯТИЯ

== Модель ресурсной сети

Ресурсная сеть представляет собой нелинейную модель потока, работающую в дискретном времени. Вершины сети синхронно перераспределяют некоторый бесконечно делимый ресурс. На каждом временном шаге каждая вершина отправляет ресурс всем своим соседям по одному из двух правил с пороговым переключением. Выбор правила зависит от количества ресурса в вершине. Если ресурс в вершине больше, чем общая пропускная способность ее исходящих ребер, он отправляет полную пропускную способность каждому ребру; в противном случае вершина отдает весь ресурс, распределяя его пропорционально пропускной способности исходящих ребер. Вершины имеют неограниченные емкости.

Структура сети задается ориентированным взвешенным графом $G = (V , E)$. Ребра $e_(i j) = (v_i , v_j) in E$ имеют постоянные во времени неотрицательные веса $r_(i j)$, определяющие пропускные способности соответствующих ребер.

Матрица $R = (r_(i j))_(n times n)$ — матрица пропускной способности, $r_(i j) in R_(+)$. Если ребро $e_(i j)$ существует, то $r_(i j) > 0$, иначе $r_(i j) = 0$.

Динамические свойства сети определяются правилами перераспределения ресурсов, а также количеством общего ресурса и его распределением по вершинам.

Ресурсы $q_i (t)$ — неотрицательные числа, присвоенные вершинам $v_i , i = overline(1"," n) ,$ и изменяющиеся в дискретном времени $t$.

Состояние $Q (t)$ c на временном шаге t представляет собой вектор значений ресурсов в каждой вершине:

$ Q (t) = (q_1 (t) , dots.h , q_n (t)) . $ <nonum>


Пусть W — общий ресурс в сети. В сети выполняется закон сохранения: ресурс не поступает и не уходит.

Значения:

$ 
r_i^(i n) = sum_(j = 1)^n r_(j i) med med и med med r_i^(o u t) = sum_(j = 1)^n r_(i j) $ <nonum>

— суммарные входящие и исходящие пропускные способности вершины $v_i$ соответственно. Пропускная способность петли, если она существует, включается в обе суммы.

На временном шаге t вершина $v_i$ отправляет соседней вершине $v_j$ через ребро $e_(i j)$ количество ресурса $f_(i j) (t)$, равное:


$ f_(i j) (t) = {r_(i j) , med upright("if") med q_i (t) > r_i^(o u t) med - med "правило" med 1\
      r_(i j) / r_i^(o u t) q_i (t) , med med upright("if") med q_i (t) lt.eq r_i^(o u t) - med п р а в и л о med 2 med $


Другими словами, если количество ресурсов вершины превышает суммарную пропускную способность исходящих ребер, то она работает по правилу 1. В этом случае поток в каждом ребре равен его пропускной способности: $f_(i j) (t) = r_(i j)$; в сумме вершина отправляет свою общую выходную пропускную способность:

$ sum_(j = 1)^n f_(i j) (t) = sum_(j = 1)^n r_(i j) = r_i^(o u t) . $


Если вершина имеет недостаточное количество ресурса, то в соответствии с правилом 2 она отдает весь свой ресурс, распределяя его на все исходящие ребра пропорционально их пропускным способностям. В таком случае

$ sum_(j = 1)^n f_(i j) (t) = q_i (t) . $


Вектор $Q^(\*) = (q_1^(\*) , dots.h , q_n^(\*)) ,$ где

$ lim_(t arrow.r oo) q_i (t) = q_i^(\*) , i = overline(1"," n) , $

(если существует) называется #emph[предельным состоянием] сети.

Если предельное состояние существует, его можно достичь за конечное время или асимптотически; это зависит от топологии сети и начального распределения ресурсов. Предельное состояние всегда устойчиво. Это означает, что если $Q (t) = Q^(\*) ,$ то $Q (t) = Q (t + 1) = dots.h$

В \[28\] было доказано, что предельное состояние существует для всех топологий ресурсных сетей, за исключением циклических сетей (сетей, в которых НОД длин всех циклов больше 1).

Пусть общий сетевой ресурс W настолько мал, что все вершины на каждом временном шаге работают по правилу 2. В этом случае на каждом временном шаге каждая вершина отдает весь ресурс. Таким образом, в матричной форме работа сети описывается формулой:

$ Q (t + 1) = Q (t) R^prime , $


$ R^prime = med mat(delim: "(", r_11 / r_1^(o u t), dots.h.c, r_(1 n) / r_1^(o u t); dots.v, dots.down, dots.v; r_(n 1) / r_n^(o u t), dots.h.c, r_(n n) / r_n^(o u t)) $


Пусть матрица $R$ такова, что при любом распределении всего ресурса $W = 1$ вся сеть работает по правилу 2. В \[28\] доказано, что в этом случае сеть описывается однородной цепью Маркова. В частности, если сеть не циклическая, то предельное состояние всегда существует и единственно.

#claim[
Регулярные ресурсные сети имеют глобальную характеристику: пороговое значение общего ресурса $med W = T$:

- Если $W < T$, то существует конечное время $t$ такое, что при $t > t'$ все вершины будут работать по правилу 2;

- Если $W = T$, все вершины будут работать по правилу 2 — за конечное время или асимптотически, в зависимости от начального распределения ресурсов;

- Если $W > T$, то существует момент времени $t''$ такой, что при $t > t''$ хотя бы одна вершина будет работать по правилу 1.
]

Ресурс $W med lt.eq T$ называется _малым_; ресурс $W > T$ называется _большим_.

#claim[
Если $W < T$, то с некоторого временного шага $t'$ все вершины отдают свой ресурс по правилу 2, и все приведенные выше результаты, полученные при $W = 1$, также будут правильными.
]

Доказано, что способность вершины стабильно функционировать по правилу 1 зависит от топологии и весов ребер графа и не зависит от начального распределения ресурсов. Вершины, способные накапливать излишки ресурсов (ресурсы, превышающие T), называются аттракторами. В \[28\] сформулирован и доказан критерий аттрактивности вершины.










#let state_1 = ("0": 8, "1": 1, "2": 0)

Пример ресурсной сети $"network"_1$ можно видеть на @fig:basic_network_1. Множество вершин здесь есть $V = {0, 1, 2}$, а метки ребер обозначают соответствующие веса в графе $G$. На @fig:basic_network_2 показано некоторое состояние сети с ресурсами #state_dict(state_1). При данном способе визуализации вершины имеют разный размер в зависимости от количества имеющегося в них ресурса. Более того, вершины $v_i$, в которых ресурс не меньше порогового значения (т.е. $q_i >= r_i^("out")$), окрашены в фиолетовый цвет, а остальные -- в салатовый.

#grid(
  columns: 2,
  align: bottom,
  [
    #figure(
      caption: [Ресурсная сеть $"network"_1$.],
      generated_image("basic_network/plot.svg")(width: 75%),
    ) <fig:basic_network_1>
  ],
  [
    #figure(
      caption: [Состояние сети $"network"_1$ при #state_dict(state_1).],
      generated_image("basic_network/sim.svg")(),
    ) <fig:basic_network_2>
  ],
)

Матрица пропускной способности $"network"_1$ приведена в формуле @eq:basic_network_R, а ее стохастическая матрица -- в формуле @eq:basic_network_R_1. Можно убедиться, что сумма значений в каждой строке стохастической матрицы равна единице.

#grid(
  columns: 2,
  [
    $
      R = mat(
        0, 3, 1;
        4, 1, 0;
        2, 2, 0;
    )
    $ <eq:basic_network_R>
  ],
  [
    $
      R' = mat(
      0   , 0.75, 0.25;
      0.8 , 0.2 , 0   ;
      0.5 , 0.5 , 0   ;
    )
    $ <eq:basic_network_R_1>
  ],
)

$ S(q) = q - (R dot bold(1))^T + bold(1)^T dot R = q + 1^T (R - R^T). $ <nonum>

Иначе говоря, в этой ситуации модель напоминает потоковую @Goldberg1989, поток не зависит от текущего состояния, а только от свойств самого графа. Напротив, если предположить, что все вершины работают по правилу 2 (т.е. $Z^-(q) = V$), то окажется, что модель получается линейной:

$ S(q) = q dot R'. $ <eq:Markov>

Поскольку матрица $R'$ -- стохастическая (т.е. сумма значений в каждой строке равна 1), то модель @eq:Markov аналогична модели цепи Маркова с непрерывным состоянием и дискретным временем @Dynkin1965.

Отметим, что "большая часть" ресурсных сетей в пределе ведут себя во многом идентично цепям Маркова. Подробное и объемлющее описание поведения обычных ресурсных сетей приведено в @ЖИЛЯКОВА2013.

== Модель ресурсной сети с жадными вершинами

Данная модификация модели обыкновенной ресурсной сети была предложена Чаплинской Н.В. в @Жилякова2021, а затем исследована в работах @Чаплинская2021 @Чаплинская2021a. Суть модели в следующем: вершины, обладающие петлей отдают свой ресурс сначала в петлю, а остаток распределяют уже согласно обыкновенному закону функционирования ресурсной сети. Получается, что такие вершины -- \ "запасливые", пытающиеся сначала "отложить" ресурс себе, а уже потом распределять его между соседями. Из такой аналогии и проистекает их название.

Одно из интересных свойств такой сети состоит в том, что при достаточно маленьком количестве ресурса и при выполнении некоторых дополнительных свойств достижимости в графе и при некотором начальном распределении ресурса по вершинам происходит так называемая "остановка" сети: 100% ресурса оказывается сосредоточено в жадных вершинах, при этом вершина не может отдавать ресурс никуда, помимо петли (поскольку ресурса у нее недостаточно). Получается, что поток в сети оказывается нулевым (за исключением петель, в которые все время поступает весь ресурс из вершин). Естественно, динамическая система оказывается стабилизированной в том смысле, что $S(q) = S^2(q)$. Пример останавливающейся сети и ее начального состояния приведены на @fig:stop_network_1, а остановившаяся сеть -- на @fig:stop_network_2.

#grid(
  columns: 2,
  align: bottom,
  [
    #figure(
      caption: [Начальное состояние стабилизирующейся сети.],
      generated_image("stop_network/sim1.svg")(),
    ) <fig:stop_network_1>
  ],
  [
    #figure(
      caption: [Та же сеть в остановившемся состоянии.],
      generated_image("stop_network/sim2.svg")(),
    ) <fig:stop_network_2>
  ],
)

Более подробное описание ситуаций, в которых сети демонстрируют подобное поведение представлено в @Чаплинская2021 (например, утверждение 5).

= ЗАКЛЮЧЕНИЕ <nonum>

Нами были исследованы симметрии губковых сетей и связи между автоморфизмами графов и динамических систем ресурсных сетей, порождающихся этими графами. С одной стороны, мы установили, что несмотря на регулярность, губковые сети теряют много своих симметрий относительно замощений плоскости, их порождающих. Вместе с тем было дано полное описание групп автоморфизмов губковых сетей (в том числе и в случае, когда "верх" и "низ" симметричны друг относительно друга). Было введено понятие факторизации ресурсных сетей и исследованы базовые ее свойства: в каких ситуациях сеть факторизуется идеально, а в каких нет? С помощью факторизации мы смогли из обыкновенных губковых сетей строить губковые сети на цилиндре, обладающие намного большим набором симметрий. Группы автоморфизмов таких сетей также были описаны полностью. Наконец, мы установили, что каждая симметрия графа ресурсной сети порождает симметрию ее как динамической системы. Полученные утверждения можно применять для облегчения моделирования и уменьшения размера анализируемой сети.

Проведенное исследование открывает широкий простор для дальнейших изысканий. С одной стороны, можно ставить вопросы о протекании ресурса через губковую сеть, например:

- При данных параметрах сети (столбцы, строки, вес всех типов ребер), каково минимальное количество ресурса, которое может быть помещено в верхние вершины так, чтобы ресурс дотек до стоковых вершин? Каково должно быть распределение этого ресурса?
- При данном начальном распределении ресурса в верхних вершинах, какую форму будет иметь "след" данного ресурса в пределе, если ресурса не хватит на то, чтобы покрыть все "потребности" жадных вершин? Какова зависимость ширины и глубины следа от параметров сети?

С другой стороны, можно исследовать возможность обобщения полученных результатов с губковых сетей на более общие динамические модели на графах, для которых симметрии графа и динамической системы будут соотноситься так же, как и в случае ресурсных сетей. Вероятно, можно найти такое обобщение, под которое подпадут и цепи Маркова, и ресурсные сети, и другие модели, в которых состояние вершины в следующий момент времени зависит лишь от текущего ее состояния и состояния всех смежных с ней вершин.

//  функционирование губковых сетей с

#[
  #let nbsp = sym.space.nobreak

  // HAHAHA, that's a dirty hack, but works in simple cases
  #let re = regex(`#([\w\d\-_]+)\[(.+)\]`.text)
  #show re: it => {
    let (func, text) = it.text.match(re).captures
    eval("#" + func + "[" + text + "]", mode: "markup")
  }

  #let re = regex(`(\d+)–(\d+)`.text)
  #show re: it => {
    let (l, r) = it.text.match(re).captures
    [#nbsp#box[#l–#r]]
  }

  #bibliography(
    "../literature/sn_literature.bib",
    title: [СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ],
    style: "../literature/gost-r-7-0-5-2008-numeric.csl",
  )
]
\
